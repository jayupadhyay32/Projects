                               /* BUFFERSIZE OF 5 */
#include <stdio.h>
#include <stdlib.h>
#include <limits.h>
#include <pthread.h>
#include <stdbool.h>
#define bufferSIZE 40

int MAX = 20001;  /* actual is 20000+1 to remove 0 */
int p_sleep;      /* Counter for producer sleeping */
int c_sleep;      /* counter for consumer sleeping */
int producer_count; /*counter for the actual producer args */
int consumer_count; /*counter for the actual consumer args */
int item_p; /*item generated by p*/
int item_c; /*item consumedb by c*/
bool isproducersleeping = false; /* Producer starts as awake */
bool isconsumersleeping = false; /* Consumer starts as awake */

pthread_mutex_t lock;        /* Lock mutex for data protection */
pthread_cond_t cond_consume; /* flag for consumer */
pthread_cond_t cond_produce; /* flag for producer */ 


 
/* Queue structure */
struct Queue
{
    int front, rear, size;
    unsigned capacity;
    int* array;
};
 
/* Queue create */ 
struct Queue* createQueue(unsigned capacity)
{
    struct Queue* queue = (struct Queue*) malloc(sizeof(struct Queue));
    queue->capacity = capacity;
    queue->front = queue->size = 0; 
    queue->rear = capacity - 1;  
    queue->array = (int*) malloc(queue->capacity * sizeof(int));
    return queue;
}
 
/* Is the queue full? */
int isFull(struct Queue* queue)
{  return (queue->size == queue->capacity);  }
 
/* Is the queue empty? */
int isEmpty(struct Queue* queue)
{  return (queue->size == 0); }
 
/* FIFO enque */
void enqueue(struct Queue* queue, int item)
{
    if (isFull(queue))
        return;
    queue->rear = (queue->rear + 1)%queue->capacity;
    queue->array[queue->rear] = item;
    queue->size = queue->size + 1;
    
}
 
/* FIFO deque */
int dequeue(struct Queue* queue)
{
    if (isEmpty(queue))
        return 0;
    int item = queue->array[queue->front];
    queue->front = (queue->front + 1)%queue->capacity;
    queue->size = queue->size - 1;
    return item;
}
 

 void* produce(void *gvar) {
struct Queue *q;
q = (struct Queue *)gvar; /*Cast the q which is given by the thread */

/*printf("Hello, i am under produce. \n"); */
while(producer_count<MAX) {
   
  pthread_mutex_lock(&lock);                    /* Protect the buffer */
  
  
  while(isFull(q) == 1) {                         /* Check if any buffer indices are full */
  pthread_cond_wait(&cond_consume, &lock);
  if(!isproducersleeping){
  isproducersleeping=true;                        /* If Queue is full, producer is sleeping*/
  p_sleep++;
                     } 
                        }
  enqueue(q,producer_count); /* produce here */
  printf("Produced something. %d\n",producer_count);
  producer_count++;
  isproducersleeping=false; /* wake producer up */
  pthread_mutex_unlock(&lock);
  pthread_cond_signal(&cond_consume); /* Producer will now be awakened */
  usleep(50000);                      /* This timer helps with segmentation faults */
  }
  pthread_exit(0);                              /* Exit the pthread  */ 
}



void* consume(void *gvar) { /* function starts */
struct Queue *q;
q = (struct Queue *)gvar;

while(consumer_count<MAX){ /*main while loop begins */

pthread_mutex_lock(&lock);                     /* Lock the buffer so errors don't occur */

while(isEmpty(q) == 1){     /*first if*/          /* If the Queue is empty */
pthread_cond_wait(&cond_produce, &lock);
if(!isconsumersleeping){
isconsumersleeping=true;      /* Consumer is now sleeping */
c_sleep++;
                  }
                      }
int output = dequeue(q);     /* Consume something */
printf("Consumed item: %d \n",output);
if((output)==(MAX-1)){
printf("Total sleeps: Prod = %d   Cons = %d \n",p_sleep,c_sleep);
exit(0); /* Kill the program */ 
}
consumer_count++;
isconsumersleeping=false; /*Wake consumer up */
pthread_mutex_unlock(&lock);
pthread_cond_signal(&cond_produce);
usleep(50000); 
}
pthread_exit(0);                               
}

int main()
{
struct Queue* q = createQueue(bufferSIZE); /* Size of Queue/Buffer goes here */
c_sleep = 0;                                    /* Counter for consumer sleeping */
p_sleep = 0;                                    /* Counter for producer sleeping */
producer_count = 0;
consumer_count = 0;
item_p = 0;
item_c = 0;

while(1){
pthread_mutex_init(&lock, NULL);                /* Initialize the Mutex */
pthread_cond_init(&cond_consume, NULL);
pthread_cond_init(&cond_produce, NULL);  

pthread_t producers1, producers2;              /* 2 threads for producer */
pthread_t consumers1, consumers2;              /* 2 threads for consumer */


/* Creating 2 Producer threads and 2 Consumer Threads */
/* ID's 1 & 2 for producer 1 & 2, ID's 3 & 4 for consumer 1 & 2 */
pthread_create(&producers1, NULL, produce, q);  /* Producer # 1 */
pthread_create(&producers2, NULL, produce, q);  /* Producer # 2 */
pthread_create(&consumers1, NULL, consume, q);  /* Consumer # 1 */
pthread_create(&consumers2, NULL, consume, q);  /* Consumer # 2 */

                       
                     }


pthread_mutex_destroy(&lock);         
pthread_cond_destroy(&cond_consume);
pthread_cond_destroy(&cond_produce);

return 0;
}

